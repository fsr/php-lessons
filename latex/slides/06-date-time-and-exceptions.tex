\input{../templates/slides_template}
\input{../templates/php_info}

% meta-information
\newcommand{\topic}{
	% TODO fill in the actual topic
	PHP-Einf√ºhrung - Lesson 7 - File Handling and dependency management
}

\title{\topic}
\date{\today}

% the actual document
\begin{document}

\maketitle

\begin{frame}{Content of this lesson}

	\setbeamertemplate{section in toc}[sections numbered]
	\tableofcontents

\end{frame}

\section{Recap}

\begin{frame}{Another more or less short recap}
	We have learned to use the OOP DateTime API that PHP provides in the last lesson. Today we will look into an procedural API for handling files (write, read, load, display and so on).
\end{frame}

\section{File Handling}

\begin{frame}{A warning before!}
	\textbf{Guys, please be very careful when manipulating files}\pause
	With little changes to your PHP code, you can cause really huge damage, like changing the wrong file, filling your HDD space or even delete your most important files by accident!
\end{frame}

\begin{frame}[fragile]{File Handling - Reading a file}

Reading a file in PHP is quite easy. \pause
\begin{lstlisting}
<?php
	readfile("path/to/file.txt");
\end{lstlisting} \pause
That's it! But PHP has even more ways to do this. Another easy one is
\begin{lstlisting}
<?php
echo file_get_contents("path/to/file.txt");
\end{lstlisting} \pause

What could be the difference?\pause

\texttt{readfile()} performs better, because it writes the file directly to the output buffer, while \texttt{file\_get\_contents()} load it into the memory first.

\end{frame}

\begin{frame}[fragile]{File Handling - Reading a file}
	
	Reading a file in PHP is quite easy. \pause
	\begin{lstlisting}
	<?php
	readfile("path/to/file.txt");
	\end{lstlisting} \pause
	That's it! But PHP has even more ways to do this. Another easy one is
	\begin{lstlisting}
	<?php
	echo file_get_contents("path/to/test.txt");
	\end{lstlisting} \pause
	
	What could be the difference?\pause
	
	\texttt{readfile()} performs better, because it writes the file directly to the output buffer, while \texttt{file\_get\_contents()} load it into the memory first.
	
\end{frame}

\begin{frame}[fragile]{File Handling - File resources}
	Let's check out some more complex situations! Mostly, you don't just want to read a file. You will work with it!\pause
	
	\begin{lstlisting}
<?php
    $path = "test.txt";
	$testFile = fopen($path, "r") or die("Unable to open the file");
	echo fread($myfile,filesize($path));
	fclose($myfile);
	\end{lstlisting}\pause
	What does the code do?\pause
	
	It tries to open the file (in read mode) first. When it doesn't exist the script terminates, otherwise it will read parts of the file. Because the length is set to the size of the file, the whole content will be read (and printed out). Then the file handler will be closed. \pause


\end{frame}

\begin{frame}[fragile]{File Handling - File handlers!?}
	So, you may ask yourself now what file handlers are.\pause
	
	File handlers are pointers on a resource, which is identified through the file name. This resource (the file) must exist and the user that runs the script needs permission to open the file! Otherwise, the \texttt{fopen()} function will fail!\pause
	
	
\end{frame}

\begin{frame}[fragile]{File Handling - File modes}
	As you have seen in the first example, \texttt{fopen()} takes an argument that sets the file mode. \textit{r} opens the file in read mode as you already know!\pause
	
	File handlers are pointers on a resource, which is identified through the file name. This resource (the file) must exist and the user that runs the script needs permission to open the file! Otherwise, the \texttt{fopen()} function will fail!\pause
	
	
\end{frame}

\section{Dependency management}

\begin{frame}[fragile]{Dependency management}
\end{frame}

\end{document}

